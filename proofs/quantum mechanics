writing programs for UQC:
. involve control from register supervisor
. register supervisor constantly manages all the subspaces originating from anywhere in the register
. there is no need to handle backend operations and manage inter-connectivity etc. and the manager will sniff out any implied connection and will go ahead and form that (see : stereotype)

tutorial on writing programs for UQC:

key idea:
. you need to use motion of physical qubits to induce motion in abstract space defined by their eigenvalues (see : eigen-stuff)
. your program uses the information attributes of the qubits to define logical properties of the program (see : attribute vs property)
. using program attributes to define computation over the set of information variables the program manages, the abstract relationship is translated to physical motion of the objects like bits and qubits (see : bit vs qubit vs boolean)
. you would write algorithms that takes care of initializing physical objects, preparing physical states, computing some function of the change, measuring the changed quantity and setting up of the next construction task


what can be done to any qubit:
. rotate
. flip
. control
. smear
. locate
. project


information processing:
. stage all the physical qubits
. initialize them in a sharp or mixed state
. program the step sequencers (see : moment generator)
. create labeled patterns (see : information state)
. assign patterns to quantum channels
. create automation clips (see : unitary operation)
. link clips to control parameters
. compose final runtime
. build executable program


running programs:
. host execution somewhere
. feed forward measured statistics
. construct other conditions on information flow


!! all comments below:

use reference computation for control:
. use packages like cirq, qiskit etc.
. construct benchmark problems in their languages
. 

create equivalent descriptions:
. describe computation involving procedures
. create representation layer for information states
. prepare all computers with identical problem description

set assertions:
. if programs written using proposed description creates identical outputs then the description is logically equivalent.
